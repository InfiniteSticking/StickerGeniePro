
import { ProcessedSprite } from '../types';

// --- Helper Functions ---

const loadImage = (src: string): Promise<HTMLImageElement> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });
};

// Check if a pixel is effectively "empty" (black background)
const isBackgroundPixel = (r: number, g: number, b: number): boolean => {
    // Strict threshold for the deep black background generated by the AI
    // Bumped to 25 to be slightly more tolerant of compression artifacts
    return r < 25 && g < 25 && b < 25; 
};

/**
 * Exact Grid Slicer
 * Splits the image into exactly 4 equal quadrants (2x2).
 * Then trims the content within each quadrant.
 */
export const sliceGrid2x2 = async (imageSrc: string): Promise<ProcessedSprite[]> => {
    const img = await loadImage(imageSrc);
    const width = img.width;
    const height = img.height;
    
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    if (!ctx) throw new Error('Could not get canvas context');
    
    ctx.drawImage(img, 0, 0);
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    // --- EXACT CENTER SPLIT ---
    // Since the AI generates a perfect square grid, we split exactly down the middle.
    const midX = Math.floor(width / 2);
    const midY = Math.floor(height / 2);

    const quadrants = [
        { x: 0, y: 0, w: midX, h: midY },          // Top Left
        { x: midX, y: 0, w: width - midX, h: midY }, // Top Right
        { x: 0, y: midY, w: midX, h: height - midY }, // Bottom Left
        { x: midX, y: midY, w: width - midX, h: height - midY } // Bottom Right
    ];

    const sprites: ProcessedSprite[] = [];

    for (const quad of quadrants) {
        if (quad.w <= 0 || quad.h <= 0) continue;

        // Find bounds of actual content within this quadrant
        let minQx = quad.w, maxQx = 0, minQy = quad.h, maxQy = 0;
        let hasContent = false;

        for (let y = 0; y < quad.h; y++) {
            for (let x = 0; x < quad.w; x++) {
                // Translate quadrant local coords to global image coords
                const globalX = quad.x + x;
                const globalY = quad.y + y;
                const idx = (globalY * width + globalX) * 4;
                
                if (!isBackgroundPixel(data[idx], data[idx+1], data[idx+2])) {
                    if (x < minQx) minQx = x;
                    if (x > maxQx) maxQx = x;
                    if (y < minQy) minQy = y;
                    if (y > maxQy) maxQy = y;
                    hasContent = true;
                }
            }
        }

        if (!hasContent) continue; // Skip empty quadrants

        // Add padding
        const PADDING = 20;
        const cropW = (maxQx - minQx + 1) + (PADDING * 2);
        const cropH = (maxQy - minQy + 1) + (PADDING * 2);

        const qCanvas = document.createElement('canvas');
        qCanvas.width = cropW;
        qCanvas.height = cropH;
        const qCtx = qCanvas.getContext('2d');
        if (!qCtx) continue;

        // Fill background black to maintain consistency
        qCtx.fillStyle = '#000000';
        qCtx.fillRect(0, 0, cropW, cropH);

        // Draw the cutout
        const sourceX = quad.x + minQx;
        const sourceY = quad.y + minQy;
        const sourceW = (maxQx - minQx + 1);
        const sourceH = (maxQy - minQy + 1);

        qCtx.drawImage(
            canvas, 
            sourceX, sourceY, sourceW, sourceH, 
            PADDING, PADDING, sourceW, sourceH
        );

        const url = qCanvas.toDataURL('image/png');
        const blob = await new Promise<Blob | null>(r => qCanvas.toBlob(r, 'image/png'));
        
        if (blob) {
            sprites.push({
                id: crypto.randomUUID(),
                url,
                width: cropW,
                height: cropH,
                blob
            });
        }
    }

    return sprites;
};
